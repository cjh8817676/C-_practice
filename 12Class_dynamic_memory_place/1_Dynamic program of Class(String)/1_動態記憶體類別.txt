動態記憶體和類別

C    語言是在"編譯期"就決定記憶體的用量()
     但可以使用malloc()、free()達成動態配置記憶體


C++  希望是在程式"執行期間"才配置記憶體
     可以使用new、delete達成動態記憶體配置

最直覺的例子就是字串，由於字串最好是傭有 "輸入多少就配置多少記憶體" 的特性
所以之後的程式範例都是以字串的角度去做學習。
可以把這章節的範例程式當作 C++ 的String物件 深度解析。


在這裡，我們在建構函式裡面的  成員變數 使用 new
           在解構函式裡面的  成員變數 使用 delete

在建構類別的時候，配置記憶體給 class裡 的成員變數。
但之後我們會發現一些問題。
------------------------------------------------------------------------------------------------
static vs const 靜態資料成員
一、 static
在 strngbad.h 裡面有一個   "static int num_strings;" (靜態變數)
在class裡面的(靜態成員變數)有個特殊性質: 不管呼叫多少個物件，只會產生一個，靜態類別的變數，為該類別的所有物件共同使用。

num_strings 只能在"類別之外"初始化，因為C++不可以在類別宣告中初始化靜態成員變數。
而且初始化要在.cpp黨 ， 不可以在.h(標頭黨)   !!!
二、 const
const 可以在 .h 黨中 宣告並初始化。
------------------------------------------------------------------------------------------------

在範例程式當中， 可以利用debug 模式 觀察 (static int num_strings) 的變化。

------------------------------------------------------------------------------------------------
我的心得: 若在class裡的"建構函數"中有使用new記憶體配置等，之後資料的處裡最好都使用call by reference 比較好喔!!!

         (num_strings 沒有++ 是因為在""複製物件""的時候  編譯器會產生(一)異種建構函數叫做  複製建構函數(copy constructor)
                                                                                      ^~~~~~~~~~~~~~~  到特殊成員函數討論




     
