在(class)類別中的  (特殊成員函數)
1. 一個 預設 建構函數      constructor
2. 一個  複製建構函數 copy constructor :(物件指定給另一個物件) !!!本章重點
3. 一個    指定運算子                  :(運算子多載)
4. 預設的    解構函數
5. 一個    位址運算子                  :(回傳this指標)        


前面提到 (num_strings 沒有++ 是因為在""複製物件""的時候  編譯器會產生(一)異種建構函數叫做  複製建構函數(copy constructor)
我們將一個物件指定給另一個物件，c++就會透過 複製建構函數(copy constructor)]。
---------------------------------------------------------
複製建構函數的 原型:  所以可以客製化。
Class_name(const Class_name &);
EX:
StringBad(const StringBad &);
---------------------------------------------------------
隱含式"複製建構函數(copy constructor)" 就是StringBad類別的問題來源。
[隱含式 複製建構函數(copy constructor)是編譯器產生的，所以裡面 num_strings 沒有++，也沒顯示物件的產生]


---------------------------------------------------------
 StringBad sports;           使用的是 預設 建構函數
 StringBad sailor = sports;  使用的是      複製建構函數
 --------------------------------------------------------

///////////////////////////////////////////////////////////////////////////////////////////////////

複製建構函數存在的原因: !!!!!!!!!!!!!!!!
StringBad sailor = sports; //會對每個成員進行複製。(包括private 成員變數)

因為private成員無法直接被存取，但是概念一樣。
-------------------------
sailor.str = sports.str;
sailor.len = sports.len
-------------------------(因為不能存取 私有成員， 所以只能透過  複製建構函數(編譯器產生，無法變更))
複製建構函數 是甚麼??? 請看2_特殊成員函數.txt。
         
///////////////////////////////////////////////////////////////////////////////////////////////////

解決方法: 1.透過 客製化 複製建構函數      (用於初始化會遇到)
            EX: StringBad sailor = sports; 

         2.透過 運算子多載 operator=()   (用於單純複製物件就會遇到)
            EX: StringBad knot;         
                knot = headline1;


中心思想:  其實2種方法都一樣的想法， 都在StringBad sailor = sports 的時候，給sailor裡的成員配置足夠的空間後，才複製sports的內容過去。

///////////////////////////////////////////////////////////////////////////////////////////////////
隱含式的"位址運算子"會回傳呼叫物件的位址(也就是this指標)
