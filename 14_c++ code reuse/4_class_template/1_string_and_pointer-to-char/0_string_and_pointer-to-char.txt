stack<char *> 可以取代 stack<string> 嗎??  答案是可以。   但是需要注意一些問題。

將原本的 stacktem.cpp 與 char_pointer_and_string.cpp做比較。!!!!!!!!!!!!!!!!!
將string 全都換成 char *
以下3種轉換都各有問題。

//////////////////////////////////////////////////////
首先要知道 string 有 "動態記憶體配置的特性(第12章)"。
    此時宣告 std::string po;
        之後每一次的輸入 cin >> po ， 都會另外配置記憶體，去儲存cin的資料。(是因為有 operator>>() 夥伴函數 的關係。)
//////////////////////////////////////////////////////


1. 將 string po 改成 
      char *po。    會遇到:      //只會產生指標，並無產生 儲存 輸入字串 的空間 (雖然編譯可以成功， 但會再cin嘗試 儲存輸入 致 不當記憶體 而當掉。)

2. 將 string po 改成 
      char po[40]。              // 型態不 匹配， "reference 不可以參考 array"

3. 將 string po 改成 
      char * po = new char[40]。 //只會配置 一次記憶體， 之後的輸入(cin)都會輸入到這個記憶體，導致再push的時候，都是將相同位址放入推疊中。

正確的使用 推疊存指標。 (請看 stacktp1.h)