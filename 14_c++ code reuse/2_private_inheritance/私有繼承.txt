前面提到 完成 has-a關係的方法: 包含其他物件 的 類別。

C++有第二種實作 has-a 關係的方法: 叫做"私有繼承"

私有繼承可以使基礎類別的 public 以及 proect 成員， 變成 衍生類別的 private成員。!!!!!!!!!!!!!!!

(第13章)
公用繼承: 基礎類別的 公用成員函數會成為 衍生類別的 公用成員函數。[簡而言之，衍生類別 繼承 基礎類別的介面， 這是屬於is-a關係]


私有繼承: 基礎類別的 公用成員函數就成為 衍生類別的 私有成員函數。[即衍生類別沒有繼承基礎類別的介面。 屬於has-a關係] [有實作 無介面]

        資料夾1 提到: 當類別包含物件就是has-a關係， 必須使用 "成員物件" 才可以使用其類別 的 成員函數。  [有實作 無介面]
        EX:
        -----------------------------------------------------------------
        class Student 
        {   
        private:
            std::string name;        // 產生string物件
            ....
        }
        int Student::GetNameLength() 
        {
            return name.size();      //使用物件 去呼叫 其類別的成員函數
        }
        -----------------------------------------------------------------
        與此相比，私有繼承     也是     has-a關係。但它不是用 成員物件， 而是使用 型態 呼叫 其類別的 成員函數。
        Ex:
        -----------------------------------------------------------------
        class Student : private std::string
        {   
            //不需要產生 string 成員物件。
        }
        int Student::GetNameLength() 
        {
            return std::string.size(); //使用型態 去呼叫 其類別的成員函數。
        }
        -----------------------------------------------------------------

"私有繼承"  與  (類別"包含"物件)， 都是has-a關係，都是 ([有實作 無介面])。

一般來說使用 類別"包含"物件 ， 去建立 has-a 關係比教不會遇到問題。

但若遇到基礎類別有protect的成員， 再去考慮要不要使用 "私有繼承" 。 
                                                因為繼承會有多重繼承的問題 1.若不同的基礎類別有同名的成員函數會遇到問題。
                                                                         2.或是不同的基礎類別有 共同祖先
                                                多重繼承的問題在資料夾3解釋。

