///////////////////////////建構函式與解構函數 的虛擬函數問題。////////////////////////////////////////
建構函式。
另外: 建構函式 不能夠為 "虛擬函數"， 建立一個衍生類別時，只會呼叫衍生類別的建構函數
                                  而衍生類別的建構函數會用到 基礎類別的建構函數作為 "成員初始串列"
      衍生類別 無法繼承 基礎類別的 建構函式。


解構函數: !!!!!!!!!!!!!!!!!!!!!!!!!!(注意)
    作為基礎類別，解構函數一般皆要設為 虛擬函數，不然在解構的時候會出現一些問題。->>-------------------------->>>v
                                                                                                          v
假設 Employee 是基礎類別                                                                                   |
假設 Singer   是衍生類別，並加入 char * 成員指向new配置的記憶體。                                             |
                                                                                                          |
當Singer物件結束的時候，理應呼叫~Singer() 解構函數會delete釋放記憶體。但會遇到一種情況。                        |
                                                                                                          |
考慮下面的程式碼:                                                                                          |
-----------------------------------------------------                                                     |
    Employee *pe =  new Singer;  //基礎類別指標   可以指向 衍生類別 的物件  !!!!!!!!!!!!!!!!(重點)           |
    ......                                                                                                v
    delete pe;  // ~Employee() or ~Singer() ???--------------------------<<----------------------------<<<<
-----------------------------------------------------
又牽涉到 動態、靜態繫結。
如果採用的是"靜態繫結"， 則delete敘述會呼叫 ~Employee() 解構函數，釋放掉Singer物件之Employee部分所指的記憶體，而不是新類別成員所指的記憶體。
    ^~~~~~~~~~~~~~~:(指的是基礎類別(Employee)沒有使用"虛擬"解構函數)

如果採用的是"動態繫結"， 則delete敘述會呼叫 ~Singer()   解構函數，是放掉Singer部分所指的記憶體，並再呼叫~Employee()解構函數，達成完全清除。


不管怎樣都會呼叫~Employee()，所以基礎類別不需要明確解構函數的服務。
但為了衍生類別能夠完全清除，我們依然不能仰賴預設的解構函數，而是要提供解構函數，包括不做事的解構函數。

virtual ~BaseClass() {}

結論:
    即使基礎類別不需要解構函數，我們都應該提供具 虛擬解構函數的基礎類別

    所以需要 虛擬解構函數!!!!!!!!!!!!!!!!!!!!!!!!!!!(重點)
////////////////////////////////////////////////////////////////////////////////

題外話:  "夥伴函數"不能設為虛擬函數，因為夥伴函數不是類別的成員，只有成員可以是虛擬函數。

//////////////////////////虛擬函數的問題///////////////////////////////////////

虛擬函數的問題，若要重新定義繼承的成員函數(虛擬成員函數)，記住一定要與原始的函數原型完全相符。(函數名稱與 引數 要完全一樣。)

例如:
-----------------------------------------------------------
class Dwelling
{
    public:
        virtual void showperks(int a) const;
    ....
};
class Hovel : public Dwelling
{
    public:                              // 重新定義並不是產生兩個多載版本的函數!!!!!!!!!!!!!!
        virtual void showperks() const;  // 重新定義繼承的成員函數並不能視為多載的情形。
        virtual void showperks(int a) const; //要像這樣完全一樣才可以
}                                          
Hovel trump;
trump.showperks(); // valid
trump/showperks(5); // invalid
-----------------------------------------------------------

再次聲明: 若要重新定義 繼承的成員函數，記住，一定要與原始的函數完全相符。
但又有一個特例。
該特例為  當 "函數回傳型態" 為 基礎類別的reference或指標，則可以置換為 衍生類別的reference或指標

例如:
-----------------------------------------------------------
class Dwelling
{
    public:
        virtual Dwelling & build(int n) ;
    ....
};
class Hovel : public Dwelling
{
    public:                              
        virtual Hovel & build(int n);      //但是，這並非所有編譯器都接受，這是新概念。
}                      
-----------------------------------------------------------

