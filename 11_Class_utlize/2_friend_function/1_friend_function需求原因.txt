請先學會"運算子多載"的概念
類別多載運算子通常都需要兩個引數
Ex:     Time weeding(4, 35);
        Time waxing(2, 47);
        Time total;
        Time adjusted;
        Time adjusted;
        total = weeding + waxing;   // use operator+()
        adjusted = total * 1.5;      // use operator*()

operator+():Time類別的加減法 都結合2個Time值  

operator*():但是乘法卻是Time類別 與 double值(adjusted = total * 1.5;)
也就是說會有
第一種情況:
A = B * 2.75;         //可行
A = B.operator*(2.75);//可行
A = 2.75 * B;         //不可行， Time物件要在左邊才會有用啊!!!!!!!! "所以不能置換呼叫"  容易出錯

------------------------------------------------------------------------------------------------
解決方案: (多載 運算子函數)

另同時存在
        |1. Time operator*(double n) const;  (成員函數)   |
        |2. friend Time operator*(double m, const Time & t)   (非成員函數) | ( 有2個operator*()但引數不同-->( 運算子多載 與 函數多載) )

非成員函數在使用時不能直接存取類別的私有資料(const Time &t抓不到物件的hours、minute資料)


解答: C++可以利用特殊的非成員函數，稱""夥伴""，可以存取 作為引數傳入的 類別的 私有成員!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
這樣
A = B * 2.75;        
A = 2.75 * B;     // 會轉成 A = operator*(2.75,B);， 可以把B的 private成員提取出來做運算。 

////////////////////////////////////////////////////////////////////////////////////////////////
記住: 夥伴函數 並非 成員函數，但是 "夥伴函數可以存取類別的private成員。"  !!!!!!!!!!!!!!!!!!!!!!(重點)

注意: 既然可以存取private為甚麼 夥伴函數 不是 類別的成員函數呢???????????????????

成員函數的特性: 類別的 成員函數 是需要透過 物件去呼叫的。

而夥伴函數 ， 為非成員函數的主要原因就是: 他不需要使用物件去呼叫。!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!(重點)
--------------------------------------------------------------------------------------------------
例如: 在 friend Time operator*(double m, const Time & t)  已被定義的情況下

A = 2.75 * B;  //不需要物件的呼叫，編譯器 就會 自動使用 friend Time operator*()，所以才會是非成員函數

物件呼叫成員函數: 例如 A.reset(3,2); // reset(int h , int m)成員函數 需要藉由物件A 呼叫，

--------------------------------------------------------------------------------------------------


